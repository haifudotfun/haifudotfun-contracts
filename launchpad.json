{"language":"Solidity","sources":{"src/haifu/HaifuLaunchpad.sol":{"content":"// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.24;\n\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport {IHaifu} from \"../interfaces/IHaifu.sol\";\nimport {IWETH} from \"../interfaces/IWETH.sol\";\nimport \"../libraries/TransferHelper.sol\";\nimport {IMatchingEngine} from \"@standardweb3/exchange/interfaces/IMatchingEngine.sol\";\n\ninterface IRevenue {\n    function feeOf(address account) external view returns (uint32 feeNum);\n\n    function isSubscribed(address account) external view returns (bool isSubscribed);\n}\n\n// HaifuLaunchpad is a MARKET_MAKER\ncontract HaifuLaunchpad is AccessControl, Initializable {\n    // Define roles\n    bytes32 public constant CREATOR = keccak256(\"CREATOR\");\n    uint256 constant DENOM = 1e8;\n\n    address public haifuFactory;\n    address public matchingEngine;\n    address public WETH;\n    address public HAIFU;\n    address public feeTo;\n    uint256 private baseFee;\n    uint256 private creatorFee;\n\n    // Haifu lifecycle\n    event HaifuLaunched(TransferHelper.TokenInfo token, IHaifu.State haifu, uint256 creatorFee);\n    event HaifuOpen(\n        address haifu, uint256 timestamp, IHaifu.OrderInfo depositOrder, IHaifu.OrderInfo haifuOrder, uint256 leftHaifu\n    );\n    event HaifuExpired(address haifu, uint256 timestamp, IHaifu.OrderInfo expireOrder, bool expiredEarly);\n    event HaifuTrackExpiary(address haifu, address managingAsset, IHaifu.OrderInfo orderInfo);\n    event HaifuWhitelisted(address haifu, address account, bool isWhitelisted);\n    event HaifuSwitchWhitelist(address haifu, bool isWhitelisted);\n\n    // Investment\n    event HaifuDeposit(address sender, address haifu, uint256 carry);\n    event HaifuCommit(\n        address haifu,\n        address sender,\n        address sent,\n        uint256 sentAmount,\n        address received,\n        uint256 receivedAmount,\n        bool isWhitelisted\n    );\n    event HaifuWithdraw(\n        address haifu,\n        address sender,\n        address sent,\n        uint256 sentAmount,\n        address received,\n        uint256 receivedAmount,\n        bool isWhitelisted\n    );\n    event HaifuClaimExpiary(\n        address account, address sent, uint256 sentAmount, address received, uint256 receivedAmount, bool expiredEarly\n    );\n\n    // errors\n    error HaifuAlreadyExists(address haifu);\n    error HaifuIsNotAccepting(address haifu, uint256 fundAcceptingExpiaryDate, uint256 current);\n    error HaifuIsNotOpen(address haifu, uint256 fundAcceptingExpiaryDate, uint256 current);\n    error HaifuIsNotExpired(address haifu, uint256 fundExpiaryDate, uint256 current);\n    error HaifuIsNotWhitelisted(address haifu, address account);\n    error AmountIsZero();\n    error InvalidHaifu();\n    error InvalidWithdrawAmount(uint256 amount, uint256 committed);\n    error OrderSizeTooSmall(uint256 converted, uint256 minRequired);\n    error InvalidAccess(address sender, address allowed);\n    error HaifuFailedToRaiseCapital(address haifu);\n\n    constructor() {\n        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);\n        _grantRole(CREATOR, msg.sender);\n    }\n\n    function initialize(\n        address _haifuFactory,\n        address _matchingEngine,\n        address _WETH,\n        address _HAIFU,\n        address _feeTo,\n        uint256 _baseFee,\n        uint256 _creatorFee\n    ) external initializer {\n        haifuFactory = _haifuFactory;\n        matchingEngine = _matchingEngine;\n        WETH = _WETH;\n        HAIFU = _HAIFU;\n        feeTo = _feeTo;\n        baseFee = _baseFee;\n        creatorFee = _creatorFee;\n    }\n\n    // admin functions\n    function setFeeTo(address _feeTo) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        feeTo = _feeTo;\n    }\n\n    function setBaseFee(uint256 _baseFee) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        baseFee = _baseFee;\n    }\n\n    function setCreatorFee(uint256 _creatorFee) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        creatorFee = _creatorFee;\n    }\n\n    function commitETH(address haifu) external payable {\n        // wrap ETH to WETH\n        require(msg.value > 0, \"Amount is zero\");\n\n        IWETH(WETH).deposit{value: msg.value}();\n        // commit to fund\n        IHaifu(haifu).commit(msg.sender, WETH, msg.value);\n    }\n\n    function commit(address haifu, address deposit, uint256 amount)\n        external\n        returns (address haifuT, uint256 haifuTAmount)\n    {\n        uint256 withoutFee = _deposit(haifu, deposit, amount);\n        // transfer to haifu token contract\n        TransferHelper.safeTransfer(deposit, haifu, withoutFee);\n        // commit to fund\n        (haifu, haifuTAmount) = IHaifu(haifu).commit(msg.sender, deposit, withoutFee);\n        emit HaifuCommit(haifu, msg.sender, deposit, amount, haifu, haifuTAmount, true);\n        return (haifu, withoutFee);\n    }\n\n    function commitHaifu(address haifu, uint256 amount) external returns (address haifuT, uint256 haifuTAmount) {\n        uint256 withoutFee = _deposit(haifu, HAIFU, amount);\n        // transfer to haifu token contract\n        TransferHelper.safeTransfer(HAIFU, haifu, withoutFee);\n        // commit to fund\n        (haifu, haifuTAmount) = IHaifu(haifu).commitHaifu(msg.sender, withoutFee);\n        emit HaifuCommit(haifu, msg.sender, HAIFU, amount, haifu, haifuTAmount, false);\n        return (haifu, haifuTAmount);\n    }\n\n    function withdraw(address haifu, uint256 amount) external returns (address deposit, uint256 depositAmount) {\n        // transfer from haifu token contract to this contract\n        TransferHelper.safeTransferFrom(haifu, msg.sender, address(this), amount);\n        // transfer to hairu token contract\n        TransferHelper.safeTransfer(haifu, haifu, amount);\n        // withdraw from fund\n        (deposit, depositAmount) = IHaifu(haifu).withdraw(msg.sender, amount);\n        emit HaifuWithdraw(haifu, msg.sender, haifu, amount, deposit, depositAmount, true);\n        return (deposit, depositAmount);\n    }\n\n    function withdrawHaifu(address haifu, uint256 amount) external returns (address deposit, uint256 depositAmount) {\n        // transfer haifu token contract from sender to this contract\n        TransferHelper.safeTransferFrom(haifu, msg.sender, address(this), amount);\n        // transfer fund to haifu token contract\n        TransferHelper.safeTransfer(haifu, haifu, amount);\n        // withdraw from fund\n        (deposit, depositAmount) = IHaifu(haifu).withdrawHaifu(msg.sender, amount);\n        emit HaifuWithdraw(haifu, msg.sender, haifu, amount, deposit, depositAmount, false);\n        return (deposit, depositAmount);\n    }\n\n    function launchHaifu(string memory name, string memory symbol, IHaifu.State memory haifu)\n        external\n        onlyRole(CREATOR)\n        returns (address ai)\n    {\n        if (!hasRole(DEFAULT_ADMIN_ROLE, msg.sender)) {\n            // Pay $HAIFU token creation fee\n            TransferHelper.safeTransferFrom(HAIFU, msg.sender, address(this), creatorFee);\n            // Send to feeTo address\n            TransferHelper.safeTransfer(HAIFU, feeTo, creatorFee);\n        }\n\n        // create haifu token\n        ai = IHaifu(haifuFactory).createHaifu(name, symbol, msg.sender, haifu);\n\n        TransferHelper.TokenInfo memory tokenInfo = TransferHelper.TokenInfo({\n            token: ai,\n            decimals: 18,\n            name: name,\n            symbol: symbol,\n            totalSupply: haifu.totalSupply\n        });\n        emit HaifuLaunched(tokenInfo, haifu, creatorFee);\n        return ai;\n    }\n\n    function setWhitelist(address haifu, address account, bool isWhitelisted)\n        external\n        onlyRole(CREATOR)\n        returns (bool)\n    {\n        IHaifu(haifu).setWhitelist(msg.sender, account, isWhitelisted);\n        emit HaifuWhitelisted(haifu, account, isWhitelisted);\n        return true;\n    }\n\n    function switchWhitelist(address haifu, bool isWhitelisted) external onlyRole(CREATOR) returns (bool) {\n        IHaifu(haifu).switchWhitelist(msg.sender, isWhitelisted);\n        emit HaifuSwitchWhitelist(haifu, isWhitelisted);\n        return true;\n    }\n\n    function openHaifu(address haifu) external onlyRole(CREATOR) returns (bool) {\n        IHaifu.HaifuOpenInfo memory info = _getHaifuInfo(haifu);\n        _validateCreator(info.creator);\n\n        if (IHaifu(haifu).isCapitalRaised()) {\n            _handleCapitalRaised(haifu, info);\n        } else {\n            revert HaifuFailedToRaiseCapital(haifu);\n        }\n        return true;\n    }\n\n    // Internal function to retrieve Haifu info\n    function _getHaifuInfo(address haifu) internal view returns (IHaifu.HaifuOpenInfo memory) {\n        return IHaifu(haifu).openInfo();\n    }\n\n    // Internal function to validate the creator\n    function _validateCreator(address creator) internal view {\n        if (creator != msg.sender) {\n            revert InvalidAccess(msg.sender, creator);\n        }\n    }\n\n    // Internal function to handle capital raised scenario\n    function _handleCapitalRaised(address haifu, IHaifu.HaifuOpenInfo memory info) internal {\n        try IMatchingEngine(matchingEngine).addPair(haifu, info.deposit, info.depositPrice, 0, info.deposit) {\n            // Successfully added the first pair\n        } catch Error(string memory) {}\n\n        try IMatchingEngine(matchingEngine).addPair(haifu, HAIFU, info.haifuPrice, 0, info.deposit) {\n            // Successfully added the second pair\n        } catch Error(string memory) {}\n\n        (IHaifu.OrderInfo memory depositOrder, IHaifu.OrderInfo memory haifuOrder, uint256 leftHaifu) =\n            IHaifu(haifu).open();\n        emit HaifuOpen(haifu, block.timestamp, depositOrder, haifuOrder, leftHaifu);\n    }\n\n    function expireHaifu(address haifu, address managingAsset)\n        external\n        onlyRole(CREATOR)\n        returns (IHaifu.OrderInfo memory expireOrder, bool expiredEarly)\n    {\n        // expire haifu's managing assets to distribute pro-rata funds to investors\n        (expireOrder, expiredEarly) = IHaifu(haifu).expire(managingAsset);\n\n        emit HaifuExpired(haifu, block.timestamp, expireOrder, expiredEarly);\n        return (expireOrder, expiredEarly);\n    }\n\n    function trackExpiary(address haifu, address managingAsset, uint32 orderId)\n        external\n        returns (IHaifu.OrderInfo memory rematchOrderInfo)\n    {\n        // track expiary, rematch bid order in HAIFU/{managingAsset} pair\n        rematchOrderInfo = IHaifu(haifu).trackExpiary(managingAsset, orderId);\n\n        emit HaifuTrackExpiary(haifu, managingAsset, rematchOrderInfo);\n        return rematchOrderInfo;\n    }\n\n    function claimExpiary(address haifu, uint256 amount)\n        external\n        returns (address claim, uint256 claimed, bool expiredEarly)\n    {\n        TransferHelper.safeTransferFrom(haifu, msg.sender, address(this), amount);\n        // send haifu token to haifu token contract\n        TransferHelper.safeTransfer(haifu, haifu, amount);\n        // claim expiary to receive $HAIFU from haifu token supply, the token contract will send $HAIFU to the sender\n        (claim, claimed, expiredEarly) = IHaifu(haifu).claimExpiary(msg.sender, amount);\n\n        emit HaifuClaimExpiary(msg.sender, haifu, amount, claim, claimed, expiredEarly);\n        return (claim, claimed, expiredEarly);\n    }\n\n    /**\n     * @dev Returns the address of the haifu for the given name, symbol and creator.\n     * @param name name of the haifu.\n     * @param symbol symbol of the haifu.\n     * @param creator creator of the haifu.\n     * @return haifu The address of haifu.\n     */\n    function getHaifu(string memory name, string memory symbol, address creator)\n        public\n        view\n        returns (IHaifu.State memory haifu)\n    {\n        return IHaifu(haifuFactory).getHaifu(name, symbol, creator);\n    }\n\n    function _deposit(address haifu, address deposit, uint256 amount) internal returns (uint256 withoutFee) {\n        // check if amount is zero\n        if (amount == 0) {\n            revert AmountIsZero();\n        }\n\n        if (haifu == address(0)) {\n            revert InvalidHaifu();\n        }\n\n        TransferHelper.safeTransferFrom(deposit, msg.sender, address(this), amount);\n        // check sender's fee\n        uint256 fee = _fee(amount, msg.sender);\n        withoutFee = amount - fee;\n\n        TransferHelper.safeTransfer(deposit, feeTo, fee);\n\n        return (withoutFee);\n    }\n\n    function _fee(uint256 amount, address account) internal view returns (uint256 fee) {\n        if (_isContract(feeTo) && IRevenue(feeTo).isSubscribed(account)) {\n            uint32 feeNum = IRevenue(feeTo).feeOf(account);\n            return (amount * feeNum) / DENOM;\n        }\n        return (amount * baseFee) / DENOM;\n    }\n\n    function _isContract(address _addr) private view returns (bool) {\n        uint256 codeLength;\n\n        // Assembly required for versions < 0.8.0 to check extcodesize.\n        assembly {\n            codeLength := extcodesize(_addr)\n        }\n\n        return codeLength > 0;\n    }\n}\n"},"lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/contracts/access/AccessControl.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/AccessControl.sol)\n\npragma solidity ^0.8.20;\n\nimport {IAccessControl} from \"./IAccessControl.sol\";\nimport {Context} from \"../utils/Context.sol\";\nimport {ERC165} from \"../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```solidity\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```solidity\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}\n * to enforce additional security measures for this role.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address account => bool) hasRole;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 role => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with an {AccessControlUnauthorizedAccount} error including the required role.\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        return _roles[role].hasRole[account];\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `_msgSender()`\n     * is missing `role`. Overriding this function changes the behavior of the {onlyRole} modifier.\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `account`\n     * is missing `role`.\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n\n        _revokeRole(role, callerConfirmation);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Attempts to grant `role` to `account` and returns a boolean indicating if `role` was granted.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (!hasRole(role, account)) {\n            _roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Attempts to revoke `role` to `account` and returns a boolean indicating if `role` was revoked.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (hasRole(role, account)) {\n            _roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n"},"lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/contracts/proxy/utils/Initializable.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```solidity\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n *\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Storage of the initializable contract.\n     *\n     * It's implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions\n     * when using with upgradeable contracts.\n     *\n     * @custom:storage-location erc7201:openzeppelin.storage.Initializable\n     */\n    struct InitializableStorage {\n        /**\n         * @dev Indicates that the contract has been initialized.\n         */\n        uint64 _initialized;\n        /**\n         * @dev Indicates that the contract is in the process of being initialized.\n         */\n        bool _initializing;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.Initializable\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\n\n    /**\n     * @dev The contract is already initialized.\n     */\n    error InvalidInitialization();\n\n    /**\n     * @dev The contract is not initializing.\n     */\n    error NotInitializing();\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint64 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that in the context of a constructor an `initializer` may be invoked any\n     * number of times. This behavior in the constructor can be useful during testing and is not expected to be used in\n     * production.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        // Cache values to avoid duplicated sloads\n        bool isTopLevelCall = !$._initializing;\n        uint64 initialized = $._initialized;\n\n        // Allowed calls:\n        // - initialSetup: the contract is not in the initializing state and no previous version was\n        //                 initialized\n        // - construction: the contract is initialized at version 1 (no reininitialization) and the\n        //                 current contract is just being deployed\n        bool initialSetup = initialized == 0 && isTopLevelCall;\n        bool construction = initialized == 1 && address(this).code.length == 0;\n\n        if (!initialSetup && !construction) {\n            revert InvalidInitialization();\n        }\n        $._initialized = 1;\n        if (isTopLevelCall) {\n            $._initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            $._initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: Setting the version to 2**64 - 1 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint64 version) {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing || $._initialized >= version) {\n            revert InvalidInitialization();\n        }\n        $._initialized = version;\n        $._initializing = true;\n        _;\n        $._initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        _checkInitializing();\n        _;\n    }\n\n    /**\n     * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.\n     */\n    function _checkInitializing() internal view virtual {\n        if (!_isInitializing()) {\n            revert NotInitializing();\n        }\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing) {\n            revert InvalidInitialization();\n        }\n        if ($._initialized != type(uint64).max) {\n            $._initialized = type(uint64).max;\n            emit Initialized(type(uint64).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint64) {\n        return _getInitializableStorage()._initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _getInitializableStorage()._initializing;\n    }\n\n    /**\n     * @dev Returns a pointer to the storage namespace.\n     */\n    // solhint-disable-next-line var-name-mixedcase\n    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n        assembly {\n            $.slot := INITIALIZABLE_STORAGE\n        }\n    }\n}\n"},"src/interfaces/IHaifu.sol":{"content":"// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.24;\n\ninterface IHaifu {\n    struct State {\n        uint256 totalSupply;\n        // carry in fraction of 1e8\n        uint256 carry;\n        address fundManager;\n        address deposit;\n        // {haifu token} / {deposit token}\n        uint256 depositPrice;\n        uint256 raised;\n        uint256 goal;\n        address HAIFU;\n        // {haifu token} / {$HAIFU}\n        uint256 haifuPrice;\n        uint256 haifuGoal;\n        uint256 haifuRaised;\n        uint256 fundAcceptingExpiaryDate;\n        uint256 fundExpiaryDate;\n    }\n\n    struct OrderInfo {\n        uint256 makePrice;\n        uint256 placed;\n        uint32 orderId;\n    }\n\n    struct HaifuOpenInfo {\n        address creator;\n        address deposit;\n        uint256 depositPrice;\n        uint256 haifuPrice;\n    }\n\n    function switchWhitelist(address sender, bool status) external;\n\n    function setWhitelist(address sender, address account, bool status) external;\n\n    function isWhitelisted(address account) external view returns (bool);\n\n    function openInfo() external view returns (HaifuOpenInfo memory);\n\n    function fundAcceptingExpiaryDate() external view returns (uint256);\n\n    function fundExpiaryDate() external view returns (uint256);\n\n    function createHaifu(string memory name, string memory symbol, address creator, State memory haifu)\n        external\n        returns (address);\n\n    function initialize(\n        string memory name,\n        string memory symbol,\n        address matchingEngine,\n        address launchpad,\n        address creator,\n        State memory haifu\n    ) external;\n\n    function commit(address sender, address deposit, uint256 amount)\n        external\n        returns (address haifu, uint256 haifuTAmount);\n\n    function commitHaifu(address sender, uint256 amount) external returns (address haifu, uint256 haifuTAmount);\n\n    function withdraw(address sender, uint256 amount) external returns (address deposit, uint256 depositAmount);\n\n    function withdrawHaifu(address sender, uint256 amount) external returns (address deposit, uint256 haifuAmount);\n\n    function trackExpiary(address managingAsset, uint32 orderId)\n        external\n        returns (IHaifu.OrderInfo memory rematchOrderInfo);\n\n    function claimExpiary(address sender, uint256 amount)\n        external\n        returns (address claim, uint256 haifuAmount, bool expiredEarly);\n\n    function getCarry(address account, uint256 amount, bool isMaker) external view returns (uint256);\n\n    function getHaifu(string memory name, string memory symbol, address creator)\n        external\n        view\n        returns (State memory state);\n\n    function getCommitted(address account) external view returns (uint256 committed);\n\n    function deposit() external view returns (address);\n\n    function raised() external view returns (uint256);\n\n    function creator() external view returns (address);\n\n    function fundManager() external view returns (address);\n\n    function goal() external view returns (uint256);\n\n    function haifuCap() external view returns (uint256);\n\n    function depositPrice() external view returns (uint256);\n\n    function haifuPrice() external view returns (uint256);\n\n    function launchPrice() external view returns (uint256);\n\n    function isCapitalRaised() external view returns (bool);\n\n    function open()\n        external\n        returns (IHaifu.OrderInfo memory depositOrderInfo, IHaifu.OrderInfo memory haifuOrderInfo, uint256 leftHaifu);\n\n    function expire(address deposit) external returns (IHaifu.OrderInfo memory rematchOrderInfo, bool expiredEarly);\n\n    function expireFundManager(address fundManager) external returns (uint256 redeemed);\n}\n"},"src/interfaces/IWETH.sol":{"content":"// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.24;\n\ninterface IWETH {\n    function deposit() external payable;\n\n    function transfer(address to, uint256 value) external returns (bool);\n\n    function withdraw(uint256) external;\n}\n"},"src/libraries/TransferHelper.sol":{"content":"// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.24;\n\nimport {ILSP7DigitalAsset} from \"@lukso/lsp7-contracts/contracts/ILSP7DigitalAsset.sol\";\n\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\nlibrary TransferHelper {\n    struct TokenInfo {\n        address token;\n        uint8 decimals;\n        string name;\n        string symbol;\n        uint256 totalSupply;\n    }\n\n    function safeApprove(address token, address to, uint256 value) internal {\n        // bytes4(keccak256(bytes(\"approve(address,uint256)\")));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"AF\");\n    }\n\n    function safeTransfer(address token, address to, uint256 value) internal {\n        // bytes4(keccak256(bytes(\"transfer(address,uint256)\")));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"TF\");\n    }\n\n    function safeTransferFrom(address token, address from, address to, uint256 value) internal {\n        // bytes4(keccak256(bytes(\"transferFrom(address,address,uint256)\")));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"TFF\");\n    }\n\n    function safeTransferETH(address to, uint256 value) internal {\n        (bool success,) = to.call{value: value}(new bytes(0));\n        require(success, \"ETF\");\n    }\n\n    function name(address token) internal view returns (string memory) {\n        // bytes4(keccak256(bytes(\"name()\")));\n        (bool success, bytes memory data) = token.staticcall(abi.encodeWithSelector(0x06fdde03));\n        require(success, \"NF\");\n        return abi.decode(data, (string));\n    }\n\n    function symbol(address token) internal view returns (string memory) {\n        // bytes4(keccak256(bytes(\"symbol()\")));\n        (bool success, bytes memory data) = token.staticcall(abi.encodeWithSelector(0x95d89b41));\n        require(success, \"SF\");\n        return abi.decode(data, (string));\n    }\n\n    function totalSupply(address token) internal view returns (uint256) {\n        // bytes4(keccak256(bytes(\"totalSupply()\")));\n        (bool success, bytes memory data) = token.staticcall(abi.encodeWithSelector(0x18160ddd));\n        require(success, \"TSF\");\n        return abi.decode(data, (uint256));\n    }\n\n    function decimals(address token) internal view returns (uint8) {\n        // bytes4(keccak256(bytes(\"decimals()\")));\n        (bool success, bytes memory data) = token.staticcall(abi.encodeWithSelector(0x313ce567));\n        require(success, \"DF\");\n        return abi.decode(data, (uint8));\n    }\n\n    function getTokenInfo(address token) internal view returns (TokenInfo memory tokenInfo) {\n        tokenInfo.token = token;\n        tokenInfo.name = name(token);\n        tokenInfo.symbol = symbol(token);\n        tokenInfo.totalSupply = totalSupply(token);\n        tokenInfo.decimals = decimals(token);\n        return tokenInfo;\n    }\n\n    function lsp7Transfer(address token, address from, address to, uint256 value) internal {\n        // bytes4(keccak256(bytes(\"transfer(address,address,uint256,bool,bytes)\")));\n        (bool success, bytes memory data) =\n            token.call(abi.encodeWithSelector(ILSP7DigitalAsset.transfer.selector, from, to, value, true, \"\"));\n\n        // Suggest using this function for abi-encoding\n        // (bool success, bytes memory data) = token.call(abi.encodeCall(ILSP7DigitalAsset.transfer, from, to, value, true, \"\"));\n        require(success && (data.length == 0), \"AF\");\n    }\n}\n"},"lib/standard3.0-contracts/src/exchange/interfaces/IMatchingEngine.sol":{"content":"// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.24;\n\ninterface IMatchingEngine {\n    // admin functions\n    function setFeeTo(address feeTo_) external returns (bool success);\n\n    function setDefaultSpread(\n        uint32 buy,\n        uint32 sell\n    ) external returns (bool success);\n\n    function setSpread(\n        address base,\n        address quote,\n        uint32 buy,\n        uint32 sell\n    ) external returns (bool success);\n\n    // user functions\n    function marketBuy(\n        address base,\n        address quote,\n        uint256 quoteAmount,\n        bool isMaker,\n        uint32 n,\n        address recipient,\n        uint32 slippageLimit\n    ) external returns (uint256 makePrice, uint256 placed, uint32 id);\n\n    function marketSell(\n        address base,\n        address quote,\n        uint256 baseAmount,\n        bool isMaker,\n        uint32 n,\n        address recipient,\n        uint32 slippageLimit\n    ) external returns (uint256 makePrice, uint256 placed, uint32 id);\n\n    function marketBuyETH(\n        address base,\n        bool isMaker,\n        uint32 n,\n        address recipient,\n        uint32 slippageLimit\n    ) external payable returns (uint256 makePrice, uint256 placed, uint32 id);\n\n    function marketSellETH(\n        address quote,\n        bool isMaker,\n        uint32 n,\n        address recipient,\n        uint32 slippageLimit\n    ) external payable returns (uint256 makePrice, uint256 placed, uint32 id);\n\n    function limitBuy(\n        address base,\n        address quote,\n        uint256 price,\n        uint256 quoteAmount,\n        bool isMaker,\n        uint32 n,\n        address recipient\n    ) external returns (uint256 makePrice, uint256 placed, uint32 id);\n\n    function limitSell(\n        address base,\n        address quote,\n        uint256 price,\n        uint256 baseAmount,\n        bool isMaker,\n        uint32 n,\n        address recipient\n    ) external returns (uint256 makePrice, uint256 placed, uint32 id);\n\n    function limitBuyETH(\n        address base,\n        uint256 price,\n        bool isMaker,\n        uint32 n,\n        address recipient\n    ) external payable returns (uint256 makePrice, uint256 placed, uint32 id);\n\n    function limitSellETH(\n        address quote,\n        uint256 price,\n        bool isMaker,\n        uint32 n,\n        address recipient\n    ) external payable returns (uint256 makePrice, uint256 placed, uint32 id);\n\n    function addPair(\n        address base,\n        address quote,\n        uint256 listingPrice,\n        uint256 listingDate,\n        address payment\n    ) external returns (address pair);\n\n    function addPairETH(\n        address base,\n        address quote,\n        uint256 listingPrice,\n        uint256 listingDate\n    ) external returns (address pair);\n\n    function cancelOrder(\n        address base,\n        address quote,\n        bool isBid,\n        uint32 orderId\n    ) external returns (uint256 refunded);\n\n    function cancelOrders(\n        address[] memory base,\n        address[] memory quote,\n        bool[] memory isBid,\n        uint32[] memory orderIds\n    ) external returns (uint256[] memory refunded);\n\n    function getOrderbookById(uint256 id) external view returns (address);\n\n    function getBaseQuote(\n        address orderbook\n    ) external view returns (address base, address quote);\n\n    function getPairs(\n        uint256 start,\n        uint256 end\n    ) external view returns (address[] memory pairs);\n\n    function getPairsWithIds(\n        uint256[] memory ids\n    ) external view returns (address[] memory pairs);\n\n    function getPairNames(\n        uint256 start,\n        uint256 end\n    ) external view returns (string[] memory names);\n\n    function getPairNamesWithIds(\n        uint256[] memory ids\n    ) external view returns (string[] memory names);\n\n    function getMktPrices(\n        uint256 start,\n        uint256 end\n    ) external view returns (uint256[] memory mktPrices);\n\n    function getMktPricesWithIds(\n        uint256[] memory ids\n    ) external view returns (uint256[] memory mktPrices);\n\n    function getPrices(\n        address base,\n        address quote,\n        bool isBid,\n        uint32 n\n    ) external view returns (uint256[] memory);\n\n    function getPricesPaginated(\n        address base,\n        address quote,\n        bool isBid,\n        uint32 start,\n        uint32 end\n    ) external view returns (uint256[] memory);\n\n    function getOrders(\n        address base,\n        address quote,\n        bool isBid,\n        uint256 price,\n        uint32 n\n    ) external view returns (address[] memory);\n\n    function getOrdersPaginated(\n        address base,\n        address quote,\n        bool isBid,\n        uint256 price,\n        uint32 start,\n        uint32 end\n    ) external view returns (address[] memory);\n\n    function getOrder(\n        address base,\n        address quote,\n        bool isBid,\n        uint32 orderId\n    ) external view returns (address);\n\n    function getOrderIds(\n        address base,\n        address quote,\n        bool isBid,\n        uint256 price,\n        uint32 n\n    ) external view returns (uint32[] memory);\n\n    function getPair(\n        address base,\n        address quote\n    ) external view returns (address book);\n\n    function heads(\n        address base,\n        address quote\n    ) external view returns (uint256 bidHead, uint256 askHead);\n\n    function mktPrice(\n        address base,\n        address quote\n    ) external view returns (uint256);\n\n    function convert(\n        address base,\n        address quote,\n        uint256 amount,\n        bool isBid\n    ) external view returns (uint256 converted);\n}\n"},"lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/contracts/access/IAccessControl.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (access/IAccessControl.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev External interface of AccessControl declared to support ERC-165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev The `account` is missing a role.\n     */\n    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);\n\n    /**\n     * @dev The caller of a function is not the expected one.\n     *\n     * NOTE: Don't confuse with {AccessControlUnauthorizedAccount}.\n     */\n    error AccessControlBadConfirmation();\n\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call. This account bears the admin role (for the granted role).\n     * Expected in cases where the role was granted using the internal {AccessControl-_grantRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) external;\n}\n"},"lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/contracts/utils/Context.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"},"lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/contracts/utils/introspection/ERC165.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC-165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"},"node_modules/@lukso/lsp7-contracts/contracts/ILSP7DigitalAsset.sol":{"content":"// SPDX-License-Identifier: Apache-2.0\n\npragma solidity ^0.8.4;\n\n// interfaces\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport {\n    IERC725Y\n} from \"@erc725/smart-contracts/contracts/interfaces/IERC725Y.sol\";\n\n/**\n * @title Interface of the LSP7 - Digital Asset standard, a fungible digital asset.\n */\ninterface ILSP7DigitalAsset is IERC165, IERC725Y {\n    // --- Events\n\n    /**\n     * @dev Emitted when the `from` transferred successfully `amount` of tokens to `to`.\n     * @param operator The address of the operator that executed the transfer.\n     * @param from The address which tokens were sent from (balance decreased by `-amount`).\n     * @param to The address that received the tokens (balance increased by `+amount`).\n     * @param amount The amount of tokens transferred.\n     * @param force if the transferred enforced the `to` recipient address to be a contract that implements the LSP1 standard or not.\n     * @param data Any additional data included by the caller during the transfer, and sent in the LSP1 hooks to the `from` and `to` addresses.\n     */\n    event Transfer(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256 amount,\n        bool force,\n        bytes data\n    );\n\n    /**\n     * @dev Emitted when `tokenOwner` enables `operator` for `amount` tokens.\n     * @param operator The address authorized as an operator\n     * @param tokenOwner The token owner\n     * @param amount The amount of tokens `operator` address has access to from `tokenOwner`\n     * @param operatorNotificationData The data to notify the operator about via LSP1.\n     */\n    event OperatorAuthorizationChanged(\n        address indexed operator,\n        address indexed tokenOwner,\n        uint256 indexed amount,\n        bytes operatorNotificationData\n    );\n\n    /**\n     * @dev Emitted when `tokenOwner` disables `operator` for `amount` tokens and set its {`authorizedAmountFor(...)`} to `0`.\n     * @param operator The address revoked from operating\n     * @param tokenOwner The token owner\n     * @param notified Bool indicating whether the operator has been notified or not\n     * @param operatorNotificationData The data to notify the operator about via LSP1.\n     */\n    event OperatorRevoked(\n        address indexed operator,\n        address indexed tokenOwner,\n        bool indexed notified,\n        bytes operatorNotificationData\n    );\n\n    // --- Token queries\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * If the asset contract has been set to be non-divisible via the `isNonDivisible_` parameter in\n     * the `constructor`, the decimals returned wiil be `0`. Otherwise `18` is the common value.\n     *\n     * @custom:notice This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {balanceOf} and {transfer}.\n     *\n     * @return the number of decimals. If `0` is returned, the asset is non-divisible.\n     */\n    function decimals() external view returns (uint8);\n\n    /**\n     * @dev Returns the number of existing tokens that have been minted in this contract.\n     * @return The number of existing tokens.\n     */\n    function totalSupply() external view returns (uint256);\n\n    // --- Token owner queries\n\n    /**\n     * @dev Get the number of tokens owned by `tokenOwner`.\n     * If the token is divisible (the {decimals} function returns `18`), the amount returned should be divided\n     * by 1e18 to get a better picture of the actual balance of the `tokenOwner`.\n     *\n     * _Example:_\n     *\n     * ```\n     * balanceOf(someAddress) -> 42_000_000_000_000_000_000 / 1e18 = 42 tokens\n     * ```\n     *\n     * @param tokenOwner The address of the token holder to query the balance for.\n     * @return The amount of tokens owned by `tokenOwner`.\n     */\n    function balanceOf(address tokenOwner) external view returns (uint256);\n\n    // --- Operator functionality\n\n    /**\n     * @dev Sets an `amount` of tokens that an `operator` has access from the caller's balance (allowance). See {authorizedAmountFor}.\n     * Notify the operator based on the LSP1-UniversalReceiver standard\n     *\n     * @param operator The address to authorize as an operator.\n     * @param amount The allowance amount of tokens operator has access to.\n     * @param operatorNotificationData The data to notify the operator about via LSP1.\n     *\n     * @custom:requirements\n     * - `operator` cannot be the zero address.\n     *\n     * @custom:events {OperatorAuthorizationChanged} when allowance is given to a new operator or\n     * an existing operator's allowance is updated.\n     */\n    function authorizeOperator(\n        address operator,\n        uint256 amount,\n        bytes memory operatorNotificationData\n    ) external;\n\n    /**\n     * @dev Enables `tokenOwner` to remove `operator` for its tokens, disallowing it to send any amount of tokens on its behalf.\n     * This function also allows the `operator` to remove itself if it is the caller of this function\n     *\n     * @param operator The address to revoke as an operator.\n     * @param tokenOwner The address of the token owner.\n     * @param notify Boolean indicating whether to notify the operator or not.\n     * @param operatorNotificationData The data to notify the operator about via LSP1.\n     *\n     * @custom:requirements\n     * - caller MUST be `operator` or `tokenOwner`\n     * - `operator` cannot be the zero address.\n     *\n     * @custom:events {OperatorRevoked} event with address of the operator being revoked for the caller (token holder).\n     */\n    function revokeOperator(\n        address operator,\n        address tokenOwner,\n        bool notify,\n        bytes memory operatorNotificationData\n    ) external;\n\n    /**\n     * @custom:info This function in the LSP7 contract can be used as a prevention mechanism\n     * against double spending allowance vulnerability.\n     *\n     * @notice Increase the allowance of `operator` by +`addedAmount`\n     *\n     * @dev Atomically increases the allowance granted to `operator` by the caller.\n     * This is an alternative approach to {authorizeOperator} that can be used as a mitigation\n     * for the double spending allowance problem.\n     * Notify the operator based on the LSP1-UniversalReceiver standard\n     *\n     * @param operator The operator to increase the allowance for `msg.sender`\n     * @param addedAmount The additional amount to add on top of the current operator's allowance\n     *\n     * @custom:requirements\n     *  - `operator` cannot be the same address as `msg.sender`\n     *  - `operator` cannot be the zero address.\n     *\n     * @custom:events {OperatorAuthorizationChanged} indicating the updated allowance\n     */\n    function increaseAllowance(\n        address operator,\n        uint256 addedAmount,\n        bytes memory operatorNotificationData\n    ) external;\n\n    /**\n     * @custom:info This function in the LSP7 contract can be used as a prevention mechanism\n     * against the double spending allowance vulnerability.\n     *\n     * @notice Decrease the allowance of `operator` by -`subtractedAmount`\n     *\n     * @dev Atomically decreases the allowance granted to `operator` by the caller.\n     * This is an alternative approach to {authorizeOperator} that can be used as a mitigation\n     * for the double spending allowance problem.\n     * Notify the operator based on the LSP1-UniversalReceiver standard\n     *\n     * @custom:events\n     *  - {OperatorAuthorizationChanged} event indicating the updated allowance after decreasing it.\n     *  - {OperatorRevoked} event if `subtractedAmount` is the full allowance,\n     *    indicating `operator` does not have any alauthorizedAmountForlowance left for `msg.sender`.\n     *\n     * @param operator The operator to decrease allowance for `msg.sender`\n     * @param tokenOwner The address of the token owner.\n     * @param subtractedAmount The amount to decrease by in the operator's allowance.\n     *\n     * @custom:requirements\n     *  - `operator` cannot be the zero address.\n     *  - `operator` must have allowance for the caller of at least `subtractedAmount`.\n     */\n    function decreaseAllowance(\n        address operator,\n        address tokenOwner,\n        uint256 subtractedAmount,\n        bytes memory operatorNotificationData\n    ) external;\n\n    /**\n     * @dev Get the amount of tokens `operator` address has access to from `tokenOwner`.\n     * Operators can send and burn tokens on behalf of their owners.\n     *\n     * @param operator The operator's address to query the authorized amount for.\n     * @param tokenOwner The token owner that `operator` has allowance on.\n     *\n     * @return The amount of tokens the `operator`'s address has access on the `tokenOwner`'s balance.\n     *\n     * @custom:info If this function is called with the same address for `operator` and `tokenOwner`, it will simply read the `tokenOwner`'s balance\n     * (since a tokenOwner is its own operator).\n     */\n    function authorizedAmountFor(\n        address operator,\n        address tokenOwner\n    ) external view returns (uint256);\n\n    /**\n     * @dev Returns all `operator` addresses that are allowed to transfer or burn on behalf of `tokenOwner`.\n     *\n     * @param tokenOwner The token owner to get the operators for.\n     * @return An array of operators allowed to transfer or burn tokens on behalf of `tokenOwner`.\n     */\n    function getOperatorsOf(\n        address tokenOwner\n    ) external view returns (address[] memory);\n\n    // --- Transfer functionality\n\n    /**\n     * @dev Transfers an `amount` of tokens from the `from` address to the `to` address and notify both sender and recipients via the LSP1 {`universalReceiver(...)`} function.\n     * If the tokens are transferred by an operator on behalf of a token holder, the allowance for the operator will be decreased by `amount` once the token transfer\n     * has been completed (See {authorizedAmountFor}).\n     *\n     * @param from The sender address.\n     * @param to The recipient address.\n     * @param amount The amount of tokens to transfer.\n     * @param force When set to `true`, the `to` address CAN be any address. When set to `false`, the `to` address MUST be a contract that supports the LSP1 UniversalReceiver standard.\n     * @param data Any additional data the caller wants included in the emitted event, and sent in the hooks of the `from` and `to` addresses.\n     *\n     * @custom:requirements\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` and `to` cannot be the same address (`from` cannot send tokens to itself).\n     * - `from` MUST have a balance of at least `amount` tokens.\n     * - If the caller is not `from`, it must be an operator for `from` with an allowance of at least `amount` of tokens.\n     *\n     * @custom:events\n     * - {Transfer} event when tokens get successfully transferred.\n     * - if the transfer is triggered by an operator, either the {OperatorAuthorizationChanged} event will be emitted with the updated allowance or the {OperatorRevoked}\n     * event will be emitted if the operator has no more allowance left.\n     *\n     * @custom:hint The `force` parameter **MUST be set to `true`** to transfer tokens to Externally Owned Accounts (EOAs)\n     * or contracts that do not implement the LSP1 Universal Receiver Standard. Otherwise the function will revert making the transfer fail.\n     *\n     * @custom:info if the `to` address is a contract that implements LSP1, it will always be notified via its `universalReceiver(...)` function, regardless if `force` is set to `true` or `false`.\n     *\n     * @custom:warning Be aware that when either the sender or the recipient can have logic that revert in their `universalReceiver(...)` function when being notified.\n     * This even if the `force` was set to `true`.\n     */\n    function transfer(\n        address from,\n        address to,\n        uint256 amount,\n        bool force,\n        bytes memory data\n    ) external;\n\n    /**\n     * @dev Same as {`transfer(...)`} but transfer multiple tokens based on the arrays of `from`, `to`, `amount`.\n     *\n     * @custom:info If any transfer in the batch fail or revert, the whole call will revert.\n     *\n     * @param from An array of sending addresses.\n     * @param to An array of receiving addresses.\n     * @param amount An array of amount of tokens to transfer for each `from -> to` transfer.\n     * @param force For each transfer, when set to `true`, the `to` address CAN be any address. When set to `false`, the `to` address MUST be a contract that supports the LSP1 UniversalReceiver standard.\n     * @param data An array of additional data the caller wants included in the emitted event, and sent in the hooks to `from` and `to` addresses.\n     *\n     * @custom:requirements\n     * - `from`, `to`, `amount` lists MUST be of the same length.\n     * - no values in `from` can be the zero address.\n     * - no values in `to` can be the zero address.\n     * - each `amount` tokens MUST be owned by `from`.\n     * - for each transfer, if the caller is not `from`, it MUST be an operator for `from` with access to at least `amount` tokens.\n     *\n     * @custom:events {Transfer} event **for each token transfer**.\n     */\n    function transferBatch(\n        address[] memory from,\n        address[] memory to,\n        uint256[] memory amount,\n        bool[] memory force,\n        bytes[] memory data\n    ) external;\n\n    /**\n     * @notice Executing the following batch of abi-encoded function calls on the contract: `data`.\n     *\n     * @dev Allows a caller to batch different function calls in one call. Perform a `delegatecall` on self, to call different functions with preserving the context.\n     * @param data An array of ABI encoded function calls to be called on the contract.\n     * @return results An array of abi-encoded data returned by the functions executed.\n     */\n    function batchCalls(\n        bytes[] calldata data\n    ) external returns (bytes[] memory results);\n}\n"},"lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/contracts/utils/introspection/IERC165.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC-165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[ERC].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[ERC section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"},"node_modules/@erc725/smart-contracts/contracts/interfaces/IERC725Y.sol":{"content":"// SPDX-License-Identifier: CC0-1.0\npragma solidity ^0.8.0;\n\n// interfaces\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\n/**\n * @title The interface for ERC725Y sub-standard, a generic data key/value store.\n * @dev ERC725Y provides the ability to set arbitrary data key/value pairs that can be changed over time.\n * It is intended to standardise certain data key/value pairs to allow automated read and writes from/to the contract storage.\n */\ninterface IERC725Y is IERC165 {\n    /**\n     * @notice The following data key/value pair has been changed in the ERC725Y storage: Data key: `dataKey`, data value: `dataValue`.\n     * @dev Emitted when data at a specific `dataKey` was changed to a new value `dataValue`.\n     * @param dataKey The data key for which a bytes value is set.\n     * @param dataValue The value to set for the given data key.\n     */\n    event DataChanged(bytes32 indexed dataKey, bytes dataValue);\n\n    /**\n     * @notice Reading the ERC725Y storage for data key `dataKey` returned the following value: `dataValue`.\n     * @dev Get in the ERC725Y storage the bytes data stored at a specific data key `dataKey`.\n     * @param dataKey The data key for which to retrieve the value.\n     * @return dataValue The bytes value stored under the specified data key.\n     */\n    function getData(\n        bytes32 dataKey\n    ) external view returns (bytes memory dataValue);\n\n    /**\n     * @notice Reading the ERC725Y storage for data keys `dataKeys` returned the following values: `dataValues`.\n     * @dev Get in the ERC725Y storage the bytes data stored at multiple data keys `dataKeys`.\n     * @param dataKeys The array of keys which values to retrieve\n     * @return dataValues The array of data stored at multiple keys\n     */\n    function getDataBatch(\n        bytes32[] memory dataKeys\n    ) external view returns (bytes[] memory dataValues);\n\n    /**\n     * @notice Setting the following data key value pair in the ERC725Y storage. Data key: `dataKey`, data value: `dataValue`.\n     *\n     * @dev Sets a single bytes value `dataValue` in the ERC725Y storage for a specific data key `dataKey`.\n     * The function is marked as payable to enable flexibility on child contracts. For instance to implement\n     * a fee mechanism for setting specific data.\n     *\n     * @param dataKey The data key for which to set a new value.\n     * @param dataValue The new bytes value to set.\n     */\n    function setData(bytes32 dataKey, bytes memory dataValue) external payable;\n\n    /**\n     * @notice Setting the following data key value pairs in the ERC725Y storage. Data keys: `dataKeys`, data values: `dataValues`.\n     *\n     * @dev Batch data setting function that behaves the same as {setData} but allowing to set multiple data key/value pairs in the ERC725Y storage in the same transaction.\n     *\n     * @param dataKeys An array of data keys to set bytes values for.\n     * @param dataValues An array of bytes values to set for each `dataKeys`.\n     */\n    function setDataBatch(\n        bytes32[] memory dataKeys,\n        bytes[] memory dataValues\n    ) external payable;\n}\n"}},"settings":{"remappings":["ds-test/=lib/openzeppelin-contracts/lib/forge-std/lib/ds-test/src/","erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/","forge-std/=lib/forge-std/src/","openzeppelin-contracts/=lib/openzeppelin-contracts/","@openzeppelin/contracts/=lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/contracts/","@openzeppelin/contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/contracts/","solidity-stringutils/=lib/openzeppelin-foundry-upgrades/lib/solidity-stringutils/","@standardweb3/=lib/standard3.0-contracts/src/","@lukso/=node_modules/@lukso/","@erc725/=node_modules/@erc725/","halmos-cheatcodes/=lib/openzeppelin-contracts-upgradeable/lib/halmos-cheatcodes/src/","openzeppelin-contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/","openzeppelin-foundry-upgrades/=lib/openzeppelin-foundry-upgrades/src/","standard3.0-contracts/=lib/standard3.0-contracts/"],"optimizer":{"enabled":true,"runs":200},"metadata":{"useLiteralContent":false,"bytecodeHash":"ipfs","appendCBOR":true},"outputSelection":{"*":{"*":["abi","evm.bytecode","evm.deployedBytecode","evm.methodIdentifiers","metadata"]}},"evmVersion":"paris","viaIR":false,"libraries":{}}}
